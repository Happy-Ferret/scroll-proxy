{"name":"scroll-proxy","tagline":"Easy scroll handling. Zero dependencies. Just 2kb.","body":"## Goal\r\n\r\nThis package is designed to help dealing with the scroll event in the **browser** in the most smoothly way possible.\r\n\r\nYes, web browsers already deliver ways to listen for the scroll event and they work really well. What `scroll-proxy` does is proxy the calls from you to the native scroll event and the other way around, doing some transformations in the process.\r\n\r\nIt applies some techniques already frequently used by web developers such as **function throttling**, **animation toggling** and a few others on **scroll**-related events. Delivering a small library one can just download and use.\r\n\r\nThe project's main focus is to help developers achieve great scroll performance in their apps while still being able to implement stuff like **scroll-based animations**, **sticky headers** and **infinite scrolling**.\r\n\r\n## Install\r\n\r\nThe installation process is pretty straight-forward.\r\n\r\nYou can get it on npm:\r\n\r\n`npm install scroll-proxy --save`\r\n\r\nOr bower:\r\n\r\n`bower install scroll-proxy --save`\r\n\r\nIf you are not into package management there is also the option of [direct download](), after unzipping the JS file will be in the `dist` folder.\r\n\r\nDon't want to download at all? No problem. Just get it from one of the [CDN providers]().\r\n\r\n## Usage\r\n\r\n### How it works\r\n\r\nOne of the biggest concerns when developing `scroll-proxy` is its interoperability with other libs and frameworks.\r\n\r\nSo we decided not to change the native scroll handling. Instead, we create a wrapper that can handle everything the native can do and more.\r\n\r\nThis way we avoid breaking any other lib that may rely on the native scroll event.\r\n\r\nThe coolest part of the lib is the event handling, you can attach as many events you like but it will only attach one listener to the native `scroll` event in the browser. This practice is often called [event delegation](https://davidwalsh.name/event-delegate).\r\n\r\nPlease setup the lib and check for yourself.\r\n\r\n### Setup\r\n\r\nSetting up the library is simple and easy.\r\n\r\nOnce you've installed it and properly added it to your document via a `script` tag you just have to instantiate a new `ScrollProxy` object.\r\n\r\n```javascript\r\nvar myScroll = new ScrollProxy();\r\n```\r\n\r\nYou just did it!\r\n\r\nNotice that you didn't pass any arguments to the `ScrollProxy` constructor. By default, ScrollProxy will always **attach** to `document.body`. It means it will report actions when the user scrolls the **page**.\r\n\r\nIf you want to get updates when the user scrolls inside some specific `HTMLElement` you must pass it to the constructor:\r\n\r\n```javascript\r\nvar myDiv = document.querySelector('.scrollable');\r\nvar myDivScroll = new ScrollProxy(myDiv);\r\n```\r\n\r\n#### Note for CommonJS/browserify users\r\n\r\nThe CommonJS module version needs you to `require` ScrollProxy before using it like above.\r\n\r\n```javascript\r\nvar ScrollProxy = require(\"scroll-proxy\");\r\n```\r\n\r\n### <a href=\"#\" id=\"on\"></a>Registering scroll events\r\n\r\nOK, ScrollProxy's set up. Now let's make some cool stuff.\r\n\r\nThe first thing you might want to do is to get updates whenever the user scrolls the page.\r\n\r\nUsually, using just browsers APIs and vanilla JS, you could do that like this:\r\n\r\n```javascript\r\nwindow.addEventListener('scroll', function() {\r\n  console.log(\"YAY, I'm scrolling!\");\r\n}, false);\r\n```\r\n\r\nAnd that would work great.\r\n\r\nBut note that it bombs your console with a lot of logs. That's because each movement on the scroll area causes one `scroll` event to fire.\r\n\r\nThat could be fine for logging as it's pretty fast but imagine doing complex calculations or animating stuff based on scroll position. That would be really slow and certainly laggy.\r\n\r\n#### Here comes `scroll-proxy` to the rescue!\r\n\r\nIn `scroll-proxy` registering an event is as easy as calling the `on` function passing the name of the event and the callback function.\r\n\r\n```javascript\r\nvar s = new ScrollProxy() // It defaults to document.body, just as we want it\r\ns.on('scroll', function() {\r\n  console.log(\"YAY, I'm scrolling!\");\r\n});\r\n```\r\n\r\nNow your `scroll` event belongs to ScrollProxy, it will automatically throttle the event calls with a 250ms delay by default.\r\n\r\nThat's great for most use cases but you can actually change it on the fly! Take a look:\r\n\r\n```javascript\r\ns.setScrollDelay(100);\r\n```\r\n\r\nNow subsequent events are respecting a 100ms delay. Easy, huh?\r\n\r\nYou could also just opt to get just a ping when the scroll event happened instead of keep monitoring, the function you are looking for is `once`. It is like `on` but, as the name implies, only fires once.\r\n\r\n```javascript\r\ns.once('scroll', function() {\r\n  console.log(\"I have just scrolled\");\r\n})\r\n```\r\n\r\nTake your time to compare both vanilla and ScrollProxy implementations and see the difference. It certainly helps tame the frenzy `scroll` event calls.\r\n\r\nFell free to the behavior using your browser inspector right here in this page. We already have a ScrollProxy instance setup in `window.myScroll`.\r\n\r\n#### ScrollProxy's custom events\r\n\r\nRegistering the `scroll` event is not the only thing ScrollProxy can do, actually it has a bunch of other cool events you can listen with the built in `on` and `once` functions.\r\n\r\nThe full list of events you can rely on:\r\n\r\n  - `scroll`\r\n  - `offsetX`\r\n  - `offsetY`\r\n  - `top`\r\n  - `bottom`\r\n  - `left`\r\n  - `right`\r\n  - `visible`\r\n  - `invisible`\r\n\r\n#### Special events\r\n\r\nSome events accept a third argument in the `on` and `once` functions. The presence of this third argument and it's value modify the event handling.\r\n\r\n**The offset events**\r\n\r\nThe `offsetX` and `offsetY` accept a third argument indicating a offset for `scroll-proxy` it to consider when firing the event. Take a look:\r\n\r\nExample:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\nCode:\r\n```javascript\r\nINSERT THE CODE\r\n```\r\n\r\nYou can also pass the third argument:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\nCode:\r\n```javascript\r\nINSERT THE CODE\r\n```\r\n\r\nNote the presence of the optional third argument on the second example. It indicates an **offset** to respect. The same logic applies to the `offsetY` event as well.\r\n\r\n**The top, bottom, left and right events**\r\n\r\nThese kind of events are usually used to determine if the user reached some of the borders of the scroll area. The third argument is useful here when you want to tell `scroll-proxy` to fire the event earlier than normal.\r\n\r\nLet's say you want to implement infinite scrolling. You could just load new stuff when the user reaches the bottom of the scroll area, right? Yes, this would work, but wouldn't it be nicer if you could actually load the content **before** the user notices any loading?\r\n\r\nFor these types of use case the third argument comes handy.\r\n\r\nSometimes you want to actually get notified when the scroll area reaches the bottom.\r\n\r\nExample:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\n```javascript\r\nINSERT CODE HERE\r\n```\r\n\r\nAnd on other times you may want to get notified earlier. You can do that by passing the third argument.\r\n\r\nExample:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\n```javascript\r\nINSERT CODE HERE\r\n```\r\n\r\n**The visible and invisible events**\r\n\r\nThese are very special events that have limited use cases but sometimes are very welcome.\r\n\r\nBoth events will only work if the third argument is given. Yes, the third argument is not optional when using either `visible` or `invisible` events.\r\n\r\nThat's because the events need to check if the element passed in the third argument is visible in the scroll area.\r\n\r\nThere's another catch: **the element to be checked must be a direct child** of the scroll area `scroll-proxy` is attached to.\r\n\r\nExample of detecting visible objects:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\n```javascript\r\nINSERT CODE HERE\r\n```\r\n\r\nExample of detecting invisible objects:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\n```javascript\r\nINSERT CODE HERE\r\n```\r\n\r\n### Getting metadata\r\n\r\n`scroll-proxy` also delivers current information about the scroll area.\r\n\r\nYou can fetch info about the x and positions, the width and height of the scroll element and also the width and height of the scroll area.\r\n\r\n```javascript\r\n// Consider a window of 800x600 with a 2000x2000 div inside\r\nvar s = new ScrollProxy();\r\nconsole.log(s.x); // Will log 0\r\nconsole.log(s.y); // Will log 0\r\nconsole.log(s.width); // Will log 800\r\nconsole.log(s.height); // Will log 600\r\nconsole.log(s.scrollWidth); // Will log 2000\r\nconsole.log(s.scrollHeight); // Will log 2000\r\n```\r\n\r\nAll the info you see above is updated realtime if you registered at least one event with `on`. In fact if you want to use these kind of info inside the event callback you could do like this:\r\n\r\nExample:\r\n\r\nINSERT EXAMPLE HERE\r\n\r\nCode:\r\n```javascript\r\nINSERT CODE HERE\r\n```\r\n\r\n### Getting rid of unused events\r\n\r\nIf you want to remove a event listener created with `on` or cancel an `once` event before it is even fired you can just use `off`.\r\n\r\n```javascript\r\nvar s = new ScrollProxy();\r\ns.on('scroll', function() {\r\n  console.log('YAY!');\r\n});\r\n\r\ns.off('scroll'); // No more YAY! logging\r\n```\r\n\r\n### Unregistering the `scroll-proxy` instances\r\n\r\nWhen you don't want an instance of `scroll-proxy` around anymore you should call `unregister` before losing the variable pointer. That way you assure the memory is clean and the events are released.\r\n\r\n```javascript\r\nvar s = new ScrollProxy();\r\ns.on('scroll', function() {\r\n  console.log('Scrolling');\r\n});\r\n\r\n// Unregistering. Stop event reports and clean stuff\r\ns.unregister(); // Stopped logging\r\n\r\ndelete s; // Clear pointer, everything OK\r\n```\r\n\r\nThe `register` function can recover unregistered instances and restore all the event handlers.\r\n\r\n```javascript\r\nvar s = new ScrollProxy();\r\ns.on('scroll', function() {\r\n  console.log('Scrolling');\r\n});\r\n\r\n// Unregistering stop event reports\r\ns.unregister(); // Stopped logging\r\n\r\ns.register(); // Logging again on scroll\r\n```\r\n\r\n**Tip!** If you already lost the variable pointing to the `scroll-proxy` instance you can just call `ScrollProxy.clean()` and get rid of all the attachments.\r\n\r\n```javascript\r\nvar s = new ScrollProxy(); // Attaching ScrollProxy to document.body\r\n\r\n// Getting scroll events\r\ns.on('scroll', function() {\r\n  console.log('Scrolling...');\r\n});\r\n\r\ndelete s; // Remove s reference\r\n\r\n// Still getting 'Scrolling...' on scroll, because s.unregister() wasn't called\r\n\r\n// Can't s.unregister() now because it's undefined :(\r\n\r\n// So clean everything with ScrollProxy.clean()! :)\r\nScrollProxy.clean();\r\n\r\n// Now it will stop logging and everything is fine again\r\n```\r\n\r\n### Dealing with animations\r\n\r\n`scroll-proxy` can be a great partner in your quest for 60FPS animations!\r\n\r\nThe first thing you need to know is that by using the custom `scroll` event you are already helping your websites performance. As you read earlier it throttles the event firing and all you need to do is select a proper **delay** using `setScrollDelay`.\r\n\r\nBut, that's not all! There is another trick we built in the library: **animation toggling**. Yes, if you have a long page with a lot of hover animations you should be aware that scrolling that page may result in a janky experience.\r\n\r\nTo solve that you'll want to use the `disableHoverOnScroll` method. It will disable all hover animations inside the scroll area when the user is scrolling, resulting in a much better experience.\r\n\r\n```javascript\r\nvar s = new ScrollProxy();\r\ns.disableHoverOnScroll();\r\n```\r\n\r\nThat's it! Don't worry, all the animations will come back to life once the user stops scrolling. It's all possible thanks to the [pointer-events](https://developer.mozilla.org/pt-BR/docs/Web/CSS/pointer-events) spec.\r\n\r\nIf you need to enable animations on scroll again for some reason you can do that:\r\n\r\n```javascript\r\ns.enableHoverOnScroll();\r\n```\r\n\r\nNotice that it applies a little delay between the scroll stop and the animation enabling, if you want to change that delay use the `setHoverDelay` method.\r\n\r\n```javascript\r\n// From now on, animations will resume after a 100ms delay after the scroll stop\r\ns.setHoverDelay(100);\r\n```\r\n\r\n#### Demo\r\n\r\nTry pressing the following button, it will toggle the hover animations on this very page. Then try scrolling over buttons to see if they react or not.\r\n\r\nINSERT DEMO BUTTON HERE\r\n\r\n### Other great functionality\r\n\r\nThere are some other great features in the lib, check the [wiki](https://github.com/mkautzmann/scroll-proxy/wiki) for more information.\r\n\r\n## Browser support\r\n\r\nThis library works with most modern browsers. Some features like the animation toggling require support for the css [pointer-events](https://developer.mozilla.org/pt-BR/docs/Web/CSS/pointer-events) spec.\r\n\r\nWe test practical support in a handful of browsers over SauceLabs, the support matrix in on the [top of this file](#top).\r\n\r\nTheoretical support should include the following browsers:\r\n\r\n| <img src=\"https://raw.githubusercontent.com/alrra/browser-logos/master/chrome/chrome_64x64.png\" width=\"32px\" height=\"32px\"> | <img src=\"https://raw.githubusercontent.com/alrra/browser-logos/master/internet-explorer/internet-explorer_64x64.png\" width=\"32px\" height=\"32px\"> | <img src=\"https://raw.githubusercontent.com/alrra/browser-logos/master/firefox/firefox_64x64.png\" width=\"32px\" height=\"32px\"> | <img src=\"https://raw.githubusercontent.com/alrra/browser-logos/master/opera/opera_64x64.png\" width=\"32px\" height=\"32px\"> | <img src=\"https://raw.githubusercontent.com/alrra/browser-logos/master/safari/safari_64x64.png\" width=\"32px\" height=\"32px\"> | <img src=\"https://raw.githubusercontent.com/alrra/browser-logos/master/edge/edge_64x64.png\" width=\"32px\" height=\"32px\">  | Android | iOS |\r\n| :---:  |:---:|  :---:  | :---: | :---:  | :---:|  :---:  |:---:|\r\n|   40+  | 11+ |   40+   |  29+  |   8+   |  12+ |   4.0+  |  8+ |\r\n\r\nYou may get it to work on older browsers as well but some features may not function properly. The table above only states fully supported browsers.\r\n\r\n## License\r\n\r\n[MIT License](LICENSE) © Matheus Kautzmann","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}